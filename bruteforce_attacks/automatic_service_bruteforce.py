import os
import subprocess
import tempfile
import logging

import xml.etree.ElementTree as ET

from datetime import datetime
from configparser import ConfigParser, ExtendedInterpolation

logger = logging.getLogger(__name__)

try:
    config_bruteforce = ConfigParser(interpolation=ExtendedInterpolation())
    config_bruteforce.read('proteciotnet.config')

    WIFI_XML_BASE_DIRECTORY = config_bruteforce.get('WIFI_PATHS', 'wifi_xml_base_directory')

    BRUTEFORCE_USERLIST_LOCATION = config_bruteforce.get('WIFI_PATHS', 'bruteforce_userlist_location')
    BRUTEFORCE_PASSWORDLIST_LOCATION = config_bruteforce.get('WIFI_PATHS', 'bruteforce_passwordlist_location')
    BRUTEFORCE_LOGS_LOCATION = config_bruteforce.get('WIFI_PATHS', 'bruteforce_logs_location')

    logger.info("Successfully loaded config file 'proteciotnet.config'")
except Exception as e:
    logger.error(f"Could not load configuration values from 'proteciotnet.config'. Error: {e} in file {__file__}")
    exit(-3)

NAME_MAP = {
    "ms-sql-s": "mssql",
    "microsoft-ds": "smbnt",
    "cifs": "smbnt",
    "pcanywheredata": "pcanywhere",
    "postgresql": "postgres",
    "shell": "rsh",
    "exec": "rexec",
    "login": "rlogin",
    "smtps": "smtp",
    "submission": "smtp",
    "imaps": "imap",
    "pop3s": "pop3",
    "iss-realsecure": "vmauthd",
    "snmptrap": "snmp"
}

_services = {}


def _parse_xml(filename:str) -> None:
    """
    Parse an XML file containing information about open ports on hosts.

    Args:
        filename (str): The path to the XML file.

    Returns:
        None
    """
    logger.info(f"Parsing {filename}...")

    supported = ['ssh', 'ftp', 'postgresql', 'telnet', 'mysql', 'ms-sql-s', 'rsh',
                 'vnc', 'imap', 'imaps', 'nntp', 'pcanywheredata', 'pop3', 'pop3s',
                 'exec', 'login', 'microsoft-ds', 'smtp', 'smtps', 'submission',
                 'svn', 'iss-realsecure', 'snmptrap', 'snmp', 'http']

    logger.debug(f"Supported: {supported}")

    tree = ET.parse(filename)
    root = tree.getroot()
    for host in root.iter('host'):
        ipaddr = host.find('address').attrib['addr']
        for port in host.iter('port'):
            cstate = port.find('state').attrib['state']
            if cstate == "open":
                try:
                    name = port.find('service').attrib['name']
                    tmp_port = port.attrib['portid']
                    iplist = ipaddr.split(',')
                except:
                    continue
                if name in supported:
                    name = NAME_MAP.get(name, name)
                    if name in _services:
                        if tmp_port in _services[name]:
                            _services[name][tmp_port] += iplist
                        else:
                            _services[name][tmp_port] = iplist
                    else:
                        _services[name] = {tmp_port: iplist}

    logger.info(f"Done parsing.")


def _check_file_format(filename: str):
    """
    Check if a given file is xml.

    Args:
        filename (str): The path to the file.

    Returns:
        str: The format of the file. Possible values are 'xml' for XML format or None if the format is not recognized.
    """
    in_format = None
    with open(filename) as f:
        filename_line = f.readlines()
        if '<?xml ' in filename_line[0] and 'nmaprun' in filename_line[1]:
            logger.debug(f"file {filename} is xml.")
            return "xml"

    logger.debug(f"file {filename} is not xml. returnin none")
    return in_format


def _brute(service: str, port: int, filename: str, output: str, single_host: str = "") -> str:
    """
    Perform brute-force attack using Medusa.

    Args:
        service (str): The name of the service.
        port (int): The port number.
        filename (str): The name of the file containing the target hosts.
        output (str): The directory where the output file will be saved.
        single_host (str, optional): The single host to attack. Defaults to "".

    Returns:
        str: The name of the log file generated by Medusa.
    """
    userlist = f'{BRUTEFORCE_USERLIST_LOCATION}/{service}/user'
    passlist = f'{BRUTEFORCE_PASSWORDLIST_LOCATION}/{service}/password'
    output_file = f'{output}/{port}-{service}-success.txt'
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    logfile_name = f'{BRUTEFORCE_LOGS_LOCATION}/{timestamp}_proteciotnet_medusa.log'

    cmd = ['medusa', '-b', '-H', filename, '-U', userlist, '-P', passlist, '-M', service, '-t', '2', '-n', port, '-T',
           '1', '-f', '-v', '5', '-w', '5', '-e' 'ns', '-O', logfile_name]

    if single_host:
        cmd = ['medusa', '-b', '-h', single_host, '-U', userlist, '-P', passlist, '-M', service, '-t', '2', '-n', port,
               '-T', '1', '-f', '-v', '5', '-w', '5', '-e' 'ns', '-O', logfile_name]

    if service == "smtp":
        cmd.extend(["-m", "AUTH:LOGIN"])

    logger.info(f"Using username list: {userlist}")
    logger.info(f"Using password list: {passlist}")
    logger.info(f"Output directory is set to: {output_file}")
    logger.info(f"Starting medusa with: {' '.join(cmd)}")

    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, bufsize=1)

    logger.info("#"*150)
    for line in p.stdout:
        logger.info(line.strip('\n'))
        if 'SUCCESS' in line:
            with open(output_file, 'a') as out_file:
                out_file.write("[+]" + line)
    logger.info("#" * 150)
    logger.info("Medusa has finished.")
    return logfile_name


def auto_bruteforce(filename: str, host: str) -> None:
    """
    Front facing function to perform automated brute-force attempts using Medusa.
    Handels all the input and output needed to bruteforce.
    Calls _brute for actual brute-force.

    Args:
        filename (str): The name of the XML file containing the target hosts and services.
        host (str): The host to target for brute-force attacks. Specify 'all' to target all hosts.

    Returns:
        None
    """
    logger.info("Starting auto bruteforcing attempt using medusa.")
    filename = f"{WIFI_XML_BASE_DIRECTORY}/{filename}"

    if os.system("command -v medusa > /dev/null") != 0:
        logger.error("Command medusa not found. Please install medusa")
        return

    if not os.path.exists(BRUTEFORCE_LOGS_LOCATION):
        logger.warning(f"{BRUTEFORCE_LOGS_LOCATION} does not exist. Trying to create it.")
        os.mkdir(BRUTEFORCE_LOGS_LOCATION)

    if os.path.isfile(filename) and _check_file_format(filename) == "xml":
        _parse_xml(filename)
    else:
        logger.error("Error loading file, please check your filename.")
        return

    try:
        tmppath = tempfile.mkdtemp(prefix="proteciotnet-tmp")
    except Exception as e_no_dir:
        logger.error(f"Error while creating temporary directory. Error {e_no_dir}")
        exit(-4)

    logger.info(f"Successfully passed all preliminary checks and parsing / {filename}")

    logfile_name = ""
    something_worked = False
    for service in _services:
        if host == "all":
            for port in _services[service]:
                logger.info(f"Instructing medusa with bruteforcing on port {port} for service {service}")
                temp_ip_filename = f'{tmppath}/tmp-{service}-{port}'
                iplist = set(_services[service][port])
                with open(temp_ip_filename, 'w+') as f:
                    for ip in iplist:
                        f.write(ip + '\n')
                logger.info(f"Successfully wrote IPs to temporary file {temp_ip_filename}")
                logfile_name = _brute(service=service,
                                      port=port,
                                      filename=temp_ip_filename,
                                      output=BRUTEFORCE_LOGS_LOCATION)
                something_worked = True
        else:
            for port in _services[service]:
                if host in _services[service][port]:
                    logger.info(f"Instructing medusa with bruteforcing {host} on port {port} for service {service}")
                    temp_ip_filename = f'{tmppath}/tmp-{service}-{port}'
                    logfile_name = _brute(service=service,
                                          port=port,
                                          filename=temp_ip_filename,
                                          output=BRUTEFORCE_LOGS_LOCATION,
                                          single_host=host)
                    something_worked = True

    if not something_worked:
        logger.error(f"Specified host {host} was not found in file {filename} or has no services to bruteforce with this toolchain")

    if something_worked and logfile_name:
        logger.info(f"The log of this scan is available at {logfile_name}")
