import hashlib
import html
import json
import os
import re

import xmltodict
try:
    from proteciotnet_dev.static.py.cwe_descriptions_dict import cwe_descriptions
except ModuleNotFoundError:
    from static.py.cwe_descriptions_dict import cwe_descriptions

_CVSS_2_PATTERN = r"CVSS 2.0 score: (\d.\d|0|\d\d.\d)"
_CVSS_3_PATTERN = r"CVSS 3.[\d|x] score: (\d.\d|0)"
_CVE_PATTERN = r"CVE-\d{4}-\d{4,7}"
_CWE_PATTERN = r"CWE-\d{1,3}"


def token_check(token):
    return True


def get_cvss_color(cvss_score, version=2):
    """
    Get color codes for CVSS score based on severity levels.

    Args:
        cvss_score (str or float): The CVSS score.
        version (int, optional): The CVSS version (2 or 3). Default is 2.

    Returns:
        tuple: A tuple containing two color codes: background color and text color.

    Example:
        get_cvss_color(5.6, version=2)
        # Returns: ('yellow', 'black')
    """

    # Define score ranges and corresponding colors for CVSS version 2
    score_range_version_2 = {
        (0, 3.9): 'green',
        (4.0, 6.9): 'yellow',
        (7.0, 10.0): 'red',
    }

    score_range_version_3 = {
        (0, 0): 'grey',
        (0.1, 3.9): 'green',
        (4.0, 6.9): 'yellow',
        (7.0, 8.9): 'orange',
        (9.0, 10.0): 'red'
    }

    try:
        cvss_score = float(cvss_score)
    except ValueError:
        return 'black', 'white'  # Return None if the cvss_score cannot be converted to a float

    if version == 2:
        for score_range, color in score_range_version_2.items():
            if score_range[0] <= cvss_score <= score_range[1]:
                return color, "black" if color != "yellow" else "white"

    elif version == 3:
        for score_range_v3, color in score_range_version_3.items():
            if score_range_v3[0] <= cvss_score <= score_range_v3[1]:
                return color, "black" if color != "yellow" else "white"

    # Return None if the cvss_score is not within any defined range
    return 'black', 'white'


def _get_cwe_description(cwe_nr):
    """
    Get the CWE description for a given CWE number.

    Args:
        cwe_nr (str): The CWE number.

    Returns:
        str: The CWE description or a default message if not found.
    """

    if cwe_nr in cwe_descriptions:
        return f"{cwe_nr}: {cwe_descriptions[cwe_nr]}"

    return "no description available"


def label_to_margin(label):
    """
    Convert a label to the corresponding margin value.

    Args:
        label (str): The label.

    Returns:
        str: The margin value or None if not found.
    """

    labels = {
        'Vulnerable': '10px',
        'Critical': '22px',
        'Warning': '28px',
        'Checked': '28px'
    }

    return labels.get(label)


def label_to_color(label):
    """
    Convert a label to the corresponding color.

    Args:
        label (str): The label.

    Returns:
        str: The color or None if not found.
    """

    labels = {
        'Vulnerable': 'red',
        'Critical': 'black',
        'Warning': 'orange',
        'Checked': 'blue'
    }

    return labels.get(label)


def from_os_type_to_font_awesome(os_type):
    """
    Convert an operating system type to the corresponding Font Awesome icon class.

    Args:
        os_type (str): The operating system type.

    Returns:
        str: The Font Awesome icon class or a default icon class if not found.
    """
    icons = {
        'windows': 'fab fa-windows',
        'solaris': 'fab fa-linux',
        'unix': 'fab fa-linux',
        'linux': 'fab fa-linux'
    }

    return icons.get(os_type.lower(), 'fas fa-question')


def nmap_ports_stats(scanfile: str) -> dict:
    """
    This module contains the `nmap_ports_stats` function that analyzes port scan data
    from an XML file generated by Nmap and returns port statistics along with debug information.

    Functions:
        nmap_ports_stats(scanfile: str) -> dict:
            Parses the Nmap XML scan data from a given file and calculates port statistics.

            Args:
                scanfile (str): The path to the Nmap XML scan file.

            Returns:
                dict: A dictionary containing port statistics and debug information.
                    - 'po' (int): Count of open ports.
                    - 'pc' (int): Count of closed ports.
                    - 'pf' (int): Count of filtered ports.
                    - 'debug' (str): JSON-encoded debug information.
                    - 'pos' (str): Formatted count of open ports.
                    - 'pcs' (str): Formatted count of closed ports.
                    - 'pfc' (str): Formatted count of filtered ports.
    """

    try:
        parsed_xml_nmap_file = xmltodict.parse(open('/opt/xml/' + scanfile, 'r').read())
    except:
        return {'po': 0, 'pc': 0, 'pf': 0}

    nmap_run_dict = parsed_xml_nmap_file['nmaprun']

    debug = {}
    ports_open, ports_closed, ports_filtered = 0, 0, 0

    if 'host' not in nmap_run_dict:
        return {'po': 0, 'pc': 0, 'pf': 0}

    port_id_counter = 0
    for items in nmap_run_dict['host']:

        if type(items) is dict:
            item = items
        else:
            item = nmap_run_dict['host']

        id_of_last_port = 0
        address = None

        if '@addr' in item['address']:
            address = item['address']['@addr']
        elif type(item['address']) is list:
            for ai in item['address']:
                if ai['@addrtype'] == 'ipv4':
                    address = ai['@addr']

        if not address:
            continue

        if 'ports' in item and 'port' in item['ports']:
            for port_object in item['ports']['port']:
                if type(port_object) is dict:
                    port = port_object
                else:
                    port = item['ports']['port']

                if id_of_last_port == port['@portid']:
                    continue
                else:
                    id_of_last_port = port['@portid']

                if address not in debug:
                    debug[address] = {'portcount': {'pc': {}, 'po': {}, 'pf': {}}}
                debug[address][port['@portid']] = port['state']

                if port['state']['@state'] == 'closed':
                    ports_closed += 1
                    debug[address]['portcount']['pc'][port_id_counter] = ports_closed
                elif port['state']['@state'] == 'open':
                    ports_open += 1
                    debug[address]['portcount']['po'][port_id_counter] = ports_open
                elif port['state']['@state'] == 'filtered':
                    ports_filtered += 1
                    debug[address]['portcount']['pf'][port_id_counter] = ports_filtered
                port_id_counter += 1

    ports_open_string = html.escape(f"{ports_open}{(4 - len(str(ports_open))) * ' '}")
    ports_closed_string = html.escape(f"{ports_closed}{(4 - len(str(ports_closed))) * ' '}")
    ports_filtered_string = html.escape(f"{ports_filtered}{(4 - len(str(ports_filtered))) * ' '}")

    return {'po': ports_open, 'pc': ports_closed, 'pf': ports_filtered, 'debug': json.dumps(debug),
            "pos": ports_open_string, "pcs:": ports_closed_string, "pfc": ports_filtered_string}


def get_cve(scanmd5: str) -> dict:
    """
    Retrieve CVE information from files based on scan MD5 hash.

    This function searches for files in the '/opt/notes' directory that match
    the provided scan MD5 hash and extracts CVE information from them.

    Args:
        scanmd5 (str): Scan MD5 hash to match against file names.

    Returns:
        dict: A dictionary containing CVE information organized by host and CVE ID.

    Example:
        get_cve("abcdef1234567890")
        # Returns: {
        #     'abcdef1234567890': {
        #         'cve1_hash': 'CVE-123-456 information...',
        #         'cve2_hash': 'CVE-789-012 information...'
        #     }
        # }
    """
    cvehost = {}
    cvefiles = os.listdir('/opt/notes')
    for cf in cvefiles:
        match = re.match(f'^({scanmd5})_([a-z0-9]{{32,32}})\\.cve$', cf)
        if match is not None:
            if match.group(1) not in cvehost:
                cvehost[match.group(1)] = {}

            if match.group(2) not in cvehost[match.group(1)]:
                cvehost[match.group(1)][match.group(2)] = open('/opt/notes/' + cf, 'r').read()

    return cvehost


def get_ports_details(scanfile: str) -> dict:
    faddress = ""
    oo = xmltodict.parse(open('/opt/xml/' + scanfile, 'r').read())
    out2 = json.dumps(oo['nmaprun'], indent=4)
    o = json.loads(out2)

    r = {'file': scanfile, 'hosts': {}}
    scanmd5 = hashlib.md5(str(scanfile).encode('utf-8')).hexdigest()

    # collect all labels in labelhost dict
    labelhost = {}
    labelfiles = os.listdir('/opt/notes')
    for lf in labelfiles:
        m = re.match('^(' + scanmd5 + ')_([a-z0-9]{32,32})\.host\.label$', lf)
        if m is not None:
            if m.group(1) not in labelhost:
                labelhost[m.group(1)] = {}
            labelhost[m.group(1)][m.group(2)] = open('/opt/notes/' + lf, 'r').read()

    # collect all notes in noteshost dict
    noteshost = {}
    notesfiles = os.listdir('/opt/notes')
    for nf in notesfiles:
        m = re.match('^(' + scanmd5 + ')_([a-z0-9]{32,32})\.notes$', nf)
        if m is not None:
            if m.group(1) not in noteshost:
                noteshost[m.group(1)] = {}
            noteshost[m.group(1)][m.group(2)] = open('/opt/notes/' + nf, 'r').read()

    # collect all cve in cvehost dict
    cvehost = get_cve(scanmd5)

    for ik in o['host']:

        # this fix single host report
        if type(ik) is dict:
            i = ik
        else:
            i = o['host']

        hostname = {}
        if 'hostnames' in i and type(i['hostnames']) is dict:
            if 'hostname' in i['hostnames']:
                if type(i['hostnames']['hostname']) is list:
                    for hi in i['hostnames']['hostname']:
                        hostname[hi['@type']] = hi['@name']
                else:
                    hostname[i['hostnames']['hostname']['@type']] = i['hostnames']['hostname']['@name'];

        if i['status']['@state'] == 'up':
            po, pc, pf = 0, 0, 0
            ss, pp, ost = {}, {}, {}
            lastportid = 0

            if '@addr' in i['address']:
                address = i['address']['@addr']
            elif type(i['address']) is list:
                for ai in i['address']:
                    if ai['@addrtype'] == 'ipv4':
                        address = ai['@addr']

            if faddress != "" and faddress != address:
                continue

            addressmd5 = hashlib.md5(str(address).encode('utf-8')).hexdigest()

            labelout = ''
            if scanmd5 in labelhost:
                if addressmd5 in labelhost[scanmd5]:
                    labelout = labelhost[scanmd5][addressmd5]

            notesout, notesb64, removenotes = '', '', ''
            if scanmd5 in noteshost:
                if addressmd5 in noteshost[scanmd5]:
                    notesb64 = noteshost[scanmd5][addressmd5]

            cveout = ''
            if scanmd5 in cvehost:
                if addressmd5 in cvehost[scanmd5]:
                    cveout = json.loads(cvehost[scanmd5][addressmd5])

            r['hosts'][address] = {'ports': [], 'hostname': hostname, 'label': labelout, 'notes': notesb64,
                                   'CVE': cveout}

            if 'ports' in i and 'port' in i['ports']:
                for pobj in i['ports']['port']:
                    if type(pobj) is dict:
                        p = pobj
                    else:
                        p = i['ports']['port']

                    if lastportid == p['@portid']:
                        continue
                    else:
                        lastportid = p['@portid']

                    v, z, e = '', '', ''
                    pp[p['@portid']] = p['@portid']

                    servicename = ''
                    if 'service' in p:
                        ss[p['service']['@name']] = p['service']['@name']

                        if '@version' in p['service']:
                            v = p['service']['@version']

                        if '@product' in p['service']:
                            z = p['service']['@product']

                        if '@extrainfo' in p['service']:
                            e = p['service']['@extrainfo']

                        servicename = p['service']['@name']

                    # if faddress != "":
                    r['hosts'][address]['ports'].append({
                        'port': p['@portid'],
                        'name': servicename,
                        'state': p['state']['@state'],
                        'protocol': p['@protocol'],
                        'reason': p['state']['@reason'],
                        'product': z,
                        'version': v,
                        'extrainfo': e
                    })
    return r


def insert_linebreaks(input_string: str, max_line_length: int = 60) -> str:
    """
    Insert line breaks into a long string to ensure each line's length does not exceed a given limit.

    Args:
        input_string (str): The input string to insert line breaks into.
        max_line_length (int, optional): Maximum length of each line. Default is 60.

    Returns:
        str: The input string with inserted line breaks into HTML paragraphs.
    """
    words = input_string.split()
    lines = []
    line = ""

    for word in words:
        if len(line) + len(word) + 1 <= max_line_length:
            if line:
                line += " " + word
            else:
                line = word
        else:
            lines.append(line)
            line = word

    if line:
        lines.append(line)

    joined_lines = "<br>".join(lines)
    return f"<p>{joined_lines}</p>"


def _split_cve_html(CVEs):
    """
    Split the HTML content containing CVE entries into individual CVE blocks.

    Args:
        cves_html (str): HTML content containing CVE entries.

    Returns:
        list: List of individual CVE blocks.
    """

    pattern = r'<div id="CVE-'
    split_strings = re.split(pattern, CVEs)
    return ['<div id="CVE-' + part for part in split_strings[1:]]


def _extract_cwe_number_from_block(cve):
    """
    Extract the numeric portion of the CWE.

    Args:
        cve (str): CVE ID.

    Returns:
        int: Extracted numeric portion of the CWE.
    """
    cwe_match = re.findall(_CWE_PATTERN, cve)
    if cwe_match:
        try:
            return int(cwe_match[-1].split("-")[1])
        except ValueError:
            return 0
    return 0


def _extract_cvss2_score(cve):
    """
    Extract the CVSS 2.0 score from a CVE block.

    Args:
        cve (str): CVE block containing CVSS 2.x score.

    Returns:
        float: Extracted CVSS 3.x score.
    """
    match = re.findall(_CVSS_2_PATTERN, cve)
    if match:
        try:
            return float(match[0])
        except ValueError:
            return 0.0
    return 0.0


def _extract_cvss3_score(cve):
    """
    Extract the CVSS 3.x score from a CVE block.

    Args:
        cve (str): CVE block containing CVSS 3.x score.

    Returns:
        float: Extracted CVSS 3.x score.
    """
    match = re.findall(_CVSS_3_PATTERN, cve)
    if match:
        try:
            return float(match[0])
        except ValueError:
            return 0.0
    return 0.0


def sort_cve_list(cve_list, key_function, reverse_order):
    """
    Sort a list of CVE blocks based on a given key function and sorting order.

    Args:
        cve_list (list): List of CVE blocks.
        key_function (callable): Function to extract the sorting key from a CVE block.
        reverse_order (bool): True for descending order, False for ascending order.

    Returns:
        str: Sorted CVE blocks as a single html string.
    """
    return ''.join(sorted(cve_list, key=key_function, reverse=reverse_order))


def sort_cve_html(cves_html, sorting_order):
    """
    Sort the HTML content containing CVE entries based on the specified sorting order.

    Args:
        cves_html (str): HTML content containing CVE entries.
        sorting_order (str): Sorting order: "cvss2asc", "cvss2desc", "cvss3asc", "cvss3desc", "cveasc", "cvedesc", 'cweasc, "cwedesc"

    Returns:
        str: Sorted HTML content of CVE entries.
    """

    split_cves = _split_cve_html(cves_html)

    if sorting_order == "cvss2asc":
        for elem in split_cves:
            print(re.findall(_CVSS_2_PATTERN, elem))
        return sort_cve_list(split_cves, _extract_cvss2_score, False)
    elif sorting_order == "cvss2desc":
        return sort_cve_list(split_cves, _extract_cvss2_score, True)

    elif sorting_order == "cvss3asc":
        return sort_cve_list(split_cves, _extract_cvss3_score, False)
    elif sorting_order == "cvss3desc":
        return sort_cve_list(split_cves, _extract_cvss3_score, True)

    elif sorting_order == "cveasc":
        return sort_cve_list(split_cves, lambda x: re.findall(_CVE_PATTERN, x)[0], False)
    elif sorting_order == "cvedesc":
        return sort_cve_list(split_cves, lambda x: re.findall(_CVE_PATTERN, x)[0], True)

    elif sorting_order == "cweasc":
        return sort_cve_list(split_cves, _extract_cwe_number_from_block, False)
    elif sorting_order == "cwedesc":
        return sort_cve_list(split_cves, _extract_cwe_number_from_block, True)

    else:
        return cves_html


def parse_config_file(filename: str = 'proteciotnet.config') -> dict:
    """
    Parse a configuration file in INI-like format and return the parsed data.

    This function reads the contents of the specified configuration file and
    parses it to create a hierarchical dictionary containing the configuration
    data.

    Args:
        filename (str, optional): The path to the configuration file to be parsed.
            Default is 'proteciotnet.config'.

    Returns:
        dict: A hierarchical dictionary containing the parsed configuration data.
            The dictionary structure is organized by sections, where each section
            is represented as a dictionary containing its associated options and
            values.

    Example:
        Given a configuration file 'example.config' with the following content:
        ```
        [Section1]
        Option1 = Value1
        Option2 = Value2

        [Section2]
        Option3 = Value3
        ```
        Calling `parse_config_file('my_config.ini')` would return:
        ```
        {
            'Section1': {
                'Option1': 'Value1',
                'Option2': 'Value2'
            },
            'Section2': {
                'Option3': 'Value3'
            }
        }
        ```

    Note:
        - Lines starting with '#' are treated as comments and are ignored.
        - The function assumes that each section header is enclosed in square brackets,
          e.g., '[Section]'.
        - Each option and value within a section should be separated by '=' and will
          be stored as strings in the parsed dictionary.
    """

    parsed_data = {}
    current_section = None

    with open(filename, 'r') as file:
        for line in file:
            line = line.strip()

            if not line or line.startswith('#'):
                continue

            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                parsed_data[current_section] = {}
            else:
                key, value = line.split('=', 1)
                parsed_data[current_section][key.strip()] = value.strip()

    return parsed_data
